


╭─────────────────────╮
│  Stored procedures  │
╰─────────────────────╯
/*
A drawback of user-defined functions is that they cannot execute transactions. In other words, inside a user-defined function, you cannot start a transaction, and commit or rollback it.

Difference between stored procedures and functions in Postgres:

- SP are used to perform operations that don't return something
- SP can manage their own transactions and can contain COMMIT and ROLLBACK
- Functions can be written in other languages like C or Python
- Functions can be used in SQL-expressions (just as built in functions as COUNT and SUM)
- Functions are assumed to be pure (no side effects)

*/

-- Setup table

drop table if exists accounts;

create table accounts (
    id int generated by default as identity,
    name varchar(100) not null,
    balance decimal(15,2) not null,
    primary key(id)
);

insert into accounts(name,balance)
values('Bob',10000);

insert into accounts(name,balance)
values('Alice',10000);

select * from accounts;

-- Create procedure

create or replace procedure transfer(
   sender int,
   receiver int, 
   amount decimal
)
language plpgsql    
as $$
begin
    -- subtracting the amount from the sender's account 
    update accounts 
    set balance = balance - amount 
    where id = sender;

    -- adding the amount to the receiver's account
    update accounts 
    set balance = balance + amount 
    where id = receiver;

    commit;
end;$$

-- You find the procedure at Schemas => public => Procedures

-- Call and verify that it works

call transfer(1,2,1000);

select * from accounts;

╭──────────────────╮
│  Drop procedure  │
╰──────────────────╯

drop procedure transfer;

╭──────────╮
│  Cursor  │
╰──────────╯

/*
A "cursor" allows you to encapsulate a query and process each individual row at a time.
 
Typically, you use cursors when you want to divide a large result set into parts and process each part individually. If you process it at once, you may have a memory overflow error.
 
declare -> open -> fetch, fetch, fetch -> close 
 
*/

-- Use "dvdrentals" for this example

create or replace function get_film_titles(p_year integer)
   returns text as $$
declare 
	 titles text default '';
	 rec_film record;
	 cur_films cursor(p_year integer)  --> the cursor expect an integer to be created
		 for select title, release_year
		 from film
		 where release_year = p_year;
begin
   -- open the cursor
   open cur_films(p_year);
	
   loop
    -- fetch one row into the film
      fetch cur_films into rec_film;

    -- exit when no more row to fetch
      exit when not found;

    -- continue build on the string "titles"
      if rec_film.title like '%ful%' then 
         titles := titles || ',' || rec_film.title || ':' || rec_film.release_year;
      end if;
   end loop;
  
   -- close the cursor
   close cur_films;

   return titles;
end; $$
language plpgsql; --> must specify language (this can also be set in the signature)

select get_film_titles(2006);
-- Returns film titles that contains "ful"
-- ",Grosse Wonderful:2006,Day Unfaithful:2006,Reap Unfaithful:2006,Unfaithful Kill:2006,Wonderful Drop:2006"

╭────────────╮
│  Triggers  │
╰────────────╯

/*

A PostgreSQL trigger is a function invoked automatically whenever an event associated with a table occurs. 
An event could be any of the following: INSERT, UPDATE, DELETE or TRUNCATE.

PostgreSQL supports row-level and statement-level triggers.
Row-level triggers may be trigged more times.

Use cases:
- if you want to keep the history of data without requiring the application to have logic to check for every event such as INSERT or UPDATE.
- when a new row is added into the customer table, other rows must be also created in tables of banks and credits.

*/

-- Setup

DROP TABLE IF EXISTS employees;
DROP TABLE IF EXISTS employee_audits;

CREATE TABLE employees(
   id INT GENERATED ALWAYS AS IDENTITY,
   first_name VARCHAR(40) NOT NULL,
   last_name VARCHAR(40) NOT NULL,
   PRIMARY KEY(id)
);

CREATE TABLE employee_audits (
   id INT GENERATED ALWAYS AS IDENTITY,
   employee_id INT NOT NULL,
   last_name VARCHAR(40) NOT NULL,
   changed_on TIMESTAMP(6) NOT NULL
);

-- A trigger function

CREATE OR REPLACE FUNCTION log_when_last_name_changes()
  RETURNS TRIGGER 
  LANGUAGE PLPGSQL
  AS
$$
BEGIN
	-- OLD = the row before the update
	-- NEW = the new row
	
	-- Only insert a row if the lastname has changed
	IF NEW.last_name <> OLD.last_name THEN
		 INSERT INTO employee_audits(employee_id,last_name,changed_on)
		 VALUES(OLD.id,OLD.last_name,now());
	END IF;

	RETURN NEW;
END;
$$

-- Visible at Schemas -> public -> Trigger Functions

-- Create a trigger:
-- if employees table is updated => run the function 
CREATE TRIGGER last_name_changes
  BEFORE UPDATE
  ON employees
  FOR EACH ROW
  EXECUTE PROCEDURE log_when_last_name_changes();

-- Visible at employees -> Triggers

-- Test the trigger
 
INSERT INTO employees (first_name, last_name)
VALUES ('John', 'Doe');

INSERT INTO employees (first_name, last_name)
VALUES ('Lily', 'Bush');

SELECT * FROM employees;
SELECT * FROM employee_audits; -- empty

-- Now the trigger should activate

UPDATE employees
SET last_name = 'Brown'
WHERE ID = 2;

SELECT * FROM employee_audits; -- one row

╭────────────────╮
│  Drop trigger  │
╰────────────────╯

drop trigger last_name_changes on employees;


╭──────────────────╮
│  Change trigger  │
╰──────────────────╯

/*
Alter trigger

Use the ALTER TRIGGER statement to rename a trigger.

DROP TRIGGER and CREATE TRIGGER to replace a trigger by a new one.
*/

ALTER TABLE employees
DISABLE TRIGGER last_name_changes;

-- Disable all

ALTER TABLE employees
DISABLE TRIGGER ALL;

-- Enable all

ALTER TABLE employees
ENABLE TRIGGER ALL;
